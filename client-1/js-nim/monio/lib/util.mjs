/*! Monio: util.mjs
    v0.34.0-pre (c) 2022 Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
fold=curry(fold,2),foldMap=curry(foldMap,2);export default{getMonadFlatMap:getMonadFlatMap,isMonad:isMonad,liftM:liftM,isFunction:isFunction,isPromise:isPromise,curry:curry,fold:fold,foldMap:foldMap,getDeferred:getDeferred};export{getMonadFlatMap};export{isMonad};export{liftM};export{isFunction};export{isPromise};export{curry};export{fold};export{foldMap};export{getDeferred};var builtInFunctions=new Set([Function.prototype.bind,Array.prototype.flatMap,Set.prototype.flatMap,function*(){}().flatMap,async function*(){}().flatMap].filter(isFunction));function getMonadFlatMap(t){var n=t.flatMap||t.chain||t.bind;return isFunction(n)?n:void 0}function isMonad(t){var n=t&&("object"==typeof t||isFunction(t))?getMonadFlatMap(t):void 0;return!(!n||builtInFunctions.has(n)||(n.toString()||"").includes("[native code]")&&!(n.name||"").startsWith("bound"))}function liftM(t){return isMonad(t)?t:Just(t)}function isFunction(t){return!(!t||"function"!=typeof t)}function isPromise(t){return!(!t||!isFunction(t.then))}function curry(t,n=t.length){return function nextCurried(o){return(...e)=>{var r=[...o,...e];return r.length>=n?t(...r):nextCurried(r)}}([])}function fold(t,n){return t.concat(n)}function foldMap(t,n,o){return o?n.reduce(((n,o)=>fold(n,t(o))),o):n.length>0?n.slice(1).reduce(((n,o)=>fold(n,t(o))),t(n[0])):void 0}function getDeferred(){var t;return{pr:new Promise((n=>t=n)),next:t}}